name: update catalog every sunday

on: [push]
    
jobs:
  build:
    name: Update the catalog.csv
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: 'python -m pip install --upgrade pip pip install regex PyYAML python-csv requests PyGithub pathlib GitPython '
        
    - name: Update the catalog.csv
      env:
        SECRET: ${{ secrets.GITHUB_TOKEN }}
      run: |
        import re
        import requests
        import yaml
        import os
        import csv
        from pathlib import Path
        from git import Repo
        from github import Github

        config = {
            "OP_ORG": "https://github.com/Openpecha"
            }

        def update_repo(g, commit_msg, new_content):
            try:
                repo = g.get_repo(f"ta4tsering/catalog")
                contents = repo.get_contents(f"./data/catalog.csv", ref="main")
                repo.update_file(contents.path, commit_msg , new_content, contents.sha, branch="main")
                print(f'catalog update completed..')
            except:
                print('Repo not found')


        def write_new_catalog(repo_path, lines):
            first_row = f"ID,Title,Volume,Author,Source ID\n"
            with open(f"{repo_path}/data/catalog.csv", 'w') as csvfile:
                csvfile.write(first_row)
                writer = csv.writer(csvfile)    
                writer.writerows(lines)


        def add_new_row_to_catalog(g, repo_path,repo_list):
            for pecha_id in repo_list:
                try:
                    repo = g.get_repo(f"Openpecha/{pecha_id}")
                    contents = repo.get_contents(f"{pecha_id}.opf/meta.yml")
                    meta_content = contents.decoded_content.decode()
                    metadata = yaml.safe_load(meta_content)
                    work_id = metadata['source_metadata']['id'][4:]
                    title = metadata['source_metadata']['title']
                except:
                    work_id = None
                    title = None
                if title == None:
                    if work_id == None:
                        row = f"[{pecha_id}](https://github.com/OpenPecha/{pecha_id}),,,,\n"
                    else:
                        row = f"[{pecha_id}](https://github.com/OpenPecha/{pecha_id}),,,,bdr:{work_id}\n"
                else:
                    if work_id != None:
                        row = f"[{pecha_id}](https://github.com/OpenPecha/{pecha_id}),{title},,,bdr:{work_id}\n"
                    else: 
                        row = f"[{pecha_id}](https://github.com/OpenPecha/{pecha_id}),{title},,,\n"
                with open(f"{repo_path}/data/catalog.csv", "a", encoding='utf-8') as csvfile:
                    csvfile.write(row)


        def add_only_repo_names_to_lines(repo_path, repo_names):
            lines = []
            repo_list = []
            key_list = []
            with open(f"{repo_path}/data/catalog.csv", newline="") as file:
                pechas = list(csv.reader(file, delimiter=","))
                for _, info in repo_names.items():
                    repo_name = info['repo']
                    pecha_avail = False
                    for pecha in pechas[1:]:
                        res = bool(pecha)
                        row = pecha
                        if res == True:
                            pecha_id = re.search("\[.+\]", pecha[0])[0][1:-1]
                            if pecha_id == repo_name:
                                lines.append(row)
                                print(f"{pecha_id} has repo")
                                pecha_avail = True
                                break
                    if pecha_avail == False:
                        print(f"{repo_name} repo is added to the catalog")
                        repo_list.append(repo_name)
            return lines, repo_list


        def get_repo_names(g):
            repo_names = {}
            curr_repo = {}
            repo_list = ["catalog","users","ebook-template","alignments",
                         "collections","data-translation-memory",
                        "openpecha-toolkit", "openpecha.github.io", "Transifex-Glossary", 
                        "W00000003","works","works-bak"]
            num = 0
            for repo in g.get_user("Openpecha").get_repos():
                print(repo.name)
                repo_name = repo.name
                if repo_name not in repo_list:
                    num += 1
                    curr_repo[num] = {
                        "repo": repo_name
                    }
                    repo_names.update(curr_repo)
                    curr_repo = {}
            return repo_names


        def get_branch(repo, branch):
            if branch in repo.heads:
                return branch
            return "master"

        def download_repo(repo_name, out_path=None, branch="main"):
            pecha_url = f"{config['OP_ORG']}/{repo_name}.git"
            out_path = Path(out_path)
            out_path.mkdir(exist_ok=True, parents=True)
            repo_path = out_path / repo_name
            Repo.clone_from(pecha_url, str(repo_path))
            repo = Repo(str(repo_path))
            branch_to_pull = get_branch(repo, branch)
            repo.git.checkout(branch_to_pull)
            return repo_path        

        if __name__ == '__main__':
            token = os.environ.get('SECRET')
            g = Github(token)
            commit_msg = "weekly catalog update done"
            headers = {"Authorization": f"bearer {token}"}
            file_path = './'
            repo_path = download_repo("catalog", file_path)
            repo_names = get_repo_names(g)
            catalog_lines, repo_list_to_add = add_only_repo_names_to_lines(g, repo_path, repo_names)
            write_new_catalog(repo_path,catalog_lines)
            add_new_row_to_catalog(g, repo_path, repo_list_to_add)
            new_catalog = Path(f"{repo_path}/data/catalog.csv").read_text(encoding='utf-8')
            update_repo(g, commit_msg, new_catalog )
      shell: python
